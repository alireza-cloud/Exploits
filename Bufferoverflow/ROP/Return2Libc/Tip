Vorgehen für die Ausarbeitung noch folgende Tipps:

1. Sicherheitsmechanismus ASLR deaktivieren. Man muss es ja nicht gleich zu Beginn extra
schwer machen. Das geht z.B. auch mit gdb-peda für die jew. Sitzung.
2. Lokalisieren der Schwachstelle
a. Was kontrollieren wir?
b. Bestimmung des Offset. (Hint: pattern_create gibt es auch für gdb-peda)
3. NX umgehen. Dafür haben wir – unter Windows – ROP kennengelernt. Wie war das nochmal
unter Linux?
4. Nutzt die man page eines geeigneten Syscall um ein vorhandenes Binary (z.B. /bin/sh)
auszuführen. Darin seht ihr welche Parameter der Syscall braucht.
5. Nun solltet ihr es schaffen, /bin/sh aufzurufen.
Erst wenn das geht empfehle ich euch, sich um ASRL zu kümmern.
6. Findet einen Adress-Leak.
7. Identifikation der Basisadresse zur Adresse des Leaks.
8. Identifikation des Offset der jew. geleakten Adresse.
9. Anpassen des Exploit, dass er den Leak übernimmt und daraus die neue Basisadresse von libc
errechnet.
10. Stack präparieren und Exploit zünden.
*************************************************************************************************
Tipps & Tricks zum Debugging unter Linux (Einstieg)
Debugging unter Linux erfolgt mit Hilfe des GDB:
apt install gdb gdb-peda
Das Zusatzpaket gdb-peda ist ein Plugin für GDB, mit dem es einfacher wird und der GDB
standardmäßig mehr Informationen an und ist somit, ohne Expertenwissen, auch einfacher nutzbar.
Darüber hinaus gibt es weitere Plugins/Konfigurationen, die auch die Darstellung des GDB etwas in
Richtung Immunity bringen, was das Fensterlayout und die standardmäßig angezeigten Informationen
betrifft. Das ist jedoch zum Großteil Geschmacksache. Auch gibt es GUIs für GDB, die vl. dem Ein oder
Anderen helfen.
Gestartet wird es mit einer entsprechenden GDB-Config, der Pfad gilt unter einem aktuellen Kali nach
der oben angeführten Installation:
└─$ cat ~/.gdbinit
set disassembly-flavor intel
source /usr/share/gdb-peda/peda.py
Um bei der main()-Funktion eines Programmes zu stoppen, hilft break main. Mit dem Befehl run
wird die Anwendung vorerst bis zum Breakpoint ausgeführt. Im oberen Bereich sind die Register
sichtbar (ACHTUNG: Die Registerwerte stellen die Werte VOR Ausführung des Aktuell mit =>
markierten Befehls dar, zeigen aktuell noch auf diesen. Sobald die Ausführung des nächsten Befehls
begonnen wird, ändert sich u.a. RIP (der Instruction Pointer auf 64-Bit Systemen):
